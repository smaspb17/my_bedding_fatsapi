import json
import importlib
import inspect
from datetime import datetime
from pathlib import Path
from enum import Enum
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import JSONResponse
from sqlalchemy import text, delete
from sqlalchemy.orm import DeclarativeBase, selectinload, joinedload
from sqlalchemy.exc import IntegrityError
from sqlmodel import SQLModel, Session, select
from app.db.database import get_session, AsyncSessionDep
from app.db.models.shop import Tag, ProductImage
from app.shop.schemas.categories import CategoryView
from app.shop.schemas.products import ProductView
from app.shop.schemas.tags import TagView, ProductTagJoinView

router = APIRouter(
    prefix="/fixtures",
    tags=["–§–∏–∫—Å—Ç—É—Ä—ã"],
)

EXPORT_PATH = Path("/mnt/c/Users/marat/Desktop/some/fixtures")
EXPORT_PATH.mkdir(parents=True, exist_ok=True)  # –°–æ–∑–¥–∞—ë–º –ø–∞–ø–∫—É, –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç

# –°–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π –≤ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–∞—Ö
MODEL_MODULES = [
    "app.db.models.shop",
    "app.db.models.users",
]

# –ö–µ—à —Å–ø–∏—Å–∫–∞ –º–æ–¥–µ–ª–µ–π (–æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ë–î)
CACHED_MODELS = {}


def discover_models():
    """–§—É–Ω–∫—Ü–∏—è –∏—â–µ—Ç –≤—Å–µ –º–æ–¥–µ–ª–∏ —Å __table__ –≤–æ –≤—Å–µ—Ö –º–æ–¥—É–ª—è—Ö –∏–∑ MODEL_MODULES."""
    global CACHED_MODELS
    models_dict = {}

    for module_path in MODEL_MODULES:
        try:
            module = importlib.import_module(module_path)  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥—É–ª—å
            for name, obj in inspect.getmembers(module):  # –ü–æ–ª—É—á–∞–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã –º–æ–¥—É–ª—è
                if (
                    inspect.isclass(obj)
                    and hasattr(obj, "__table__")
                    and (issubclass(obj, SQLModel)
                         or issubclass(obj, DeclarativeBase))
                ):
                    models_dict[name.lower()] = (
                        obj  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ { "Product": Product }
                    )
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª—è {module_path}: {e}")

    CACHED_MODELS = models_dict  # –ö–µ—à–∏—Ä—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏
    return models_dict


# –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫ –º–æ–¥–µ–ª–µ–π –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–µ—Ä–≤–µ—Ä–∞
discover_models()


class ModelNameEnum(str, Enum):
    """–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π Enum –¥–ª—è –≤—ã–ø–∞–¥–∞—é—â–µ–≥–æ —Å–ø–∏—Å–∫–∞ –º–æ–¥–µ–ª–µ–π."""

    @classmethod
    def _missing_(cls, value):
        raise ValueError(
            f"–ú–æ–¥–µ–ª—å '{value}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ –∏–∑: {list(CACHED_MODELS.keys())}"
        )


# –°–æ–∑–¥–∞—ë–º Enum –∏–∑ –∫–µ—à–∞
ModelNameEnum = Enum(
    "ModelNameEnum", {name.upper(): name for name in CACHED_MODELS.keys()}
)

SCHEMAS = {
    'category': CategoryView,
    'tag': TagView,
    'producttagjoin': ProductTagJoinView,
    'product': ProductView
}


@router.get(
    "/export/{model_name}",
    summary="üõë –í—ã–≥—Ä—É–∑–∫–∞ —Ñ–∏–∫—Å—Ç—É—Ä –≤ —Ñ–∞–π–ª. ‚ùó‚ùó–°–ø–µ—Ä–≤–∞ –ø—Ä–æ–≤–µ—Ä—å –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö‚ùó‚ùó",
)
async def export_data(model_name: ModelNameEnum, session: AsyncSessionDep):
    """
    –°–æ–∑–¥–∞–Ω–∏–µ json-—Ñ–∞–π–ª–∞ —Å —Ñ–∏–∫—Å—Ç—É—Ä–∞–º–∏ –º–æ–¥–µ–ª–∏ –ë–î.
    - –í—ã–±–µ—Ä–∏ –º–æ–¥–µ–ª—å –ë–î, –∏–∑ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥—É—Ç –≤—ã–≥—Ä—É–∂–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –≤ –æ–¥–Ω–æ–∏–º–µ–Ω–Ω—ã–π json-—Ñ–∞–π–ª.
    - –ê–¥—Ä–µ—Å —Å–æ–∑–¥–∞–Ω–∏—è —Ñ–∞–π–ª–∞ —É–∫–∞–∑–∞–Ω –≤ fixtures.py.
    - –ú–æ–¥–µ–ª–∏ –≤ –≤—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.
    """
    model_db = CACHED_MODELS.get(model_name.value)
    schema = SCHEMAS.get(model_name.value)
    if not model_db:
        raise HTTPException(status_code=400, detail="–ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    if model_name.value == 'product':
        query = (
        select(model_db)
            .options(selectinload(model_db.tags))
            .options(joinedload(model_db.images))
    )
    else:
        query = select(model_db)
    result = await session.execute(query)
    objects = result.scalars().unique().all()

    file_path = EXPORT_PATH / f"{model_name.value}.json"
    try:
        with file_path.open("w", encoding="utf-8") as f:
            json.dump(
                {model_name.value: [schema.model_validate(obj).model_dump(mode="json") for obj in objects]},
                f,
                ensure_ascii=False,
                indent=2,
            )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f'–û—à–∏–±–∫–∞ –≤—ã–≥—Ä—É–∑–∫–∏ —Ñ–∏–∫—Å—Ç—É—Ä –≤ —Ñ–∞–π–ª: {e}')

    print(f"–ü—É—Ç—å —Ñ–∞–π–ª–∞: {file_path}")
    print(f"–°—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–∞–ø–∫–∞? {EXPORT_PATH.exists()}")
    print(f"–¢–µ–∫—É—â–∞—è —Ä–∞–±–æ—á–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {Path.cwd()}")

    return {"message": f"–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –≤—ã–≥—Ä—É–∂–µ–Ω—ã –≤ {file_path}"}


@router.post("/import/{model_name}", summary="–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–∫—Å—Ç—É—Ä –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö")
async def import_data(model_name: ModelNameEnum, session: AsyncSessionDep):
    """
    –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–∫—Å—Ç—É—Ä –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏–∑ json-—Ñ–∞–π–ª–∞.
    - ‚ùó –ü–µ—Ä–µ–¥ –∑–∞–≥—Ä—É–∑–∫–æ–π –∏–∑ —Ñ–∞–π–ª–∞, –¥–∞–Ω–Ω—ã–µ –≤ –ë–î –∏–∑ —É–∫–∞–∑–∞–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã.
    - –í—ã–±–µ—Ä–∏ –º–æ–¥–µ–ª—å –ë–î, –≤ –∫–æ—Ç–æ—Ä—É—é –±—É–¥—É—Ç –≤—ã–≥—Ä—É–∂–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∏–∑ –æ–¥–Ω–æ–∏–º–µ–Ω–Ω–æ–≥–æ json-—Ñ–∞–π–ª–∞.
    - –ê–¥—Ä–µ—Å –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è —Ñ–∞–π–ª–∞ —É–∫–∞–∑–∞–Ω –≤ fixtures.py.
    - –ú–æ–¥–µ–ª–∏ –≤ –≤—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.
    """
    model_db = CACHED_MODELS.get(model_name.value)
    if not model_db:
        raise HTTPException(status_code=400, detail="–ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    file_path = EXPORT_PATH / f"{model_name.value}.json"
    if not file_path.exists():
        raise HTTPException(status_code=400, detail="–§–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω")

    with file_path.open("r", encoding="utf-8") as f:
        data = json.load(f)

    # –û—á–∏—Å—Ç–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É –ø–µ—Ä–µ–¥ –∑–∞–≥—Ä—É–∑–∫–æ–π –¥–∞–Ω–Ω—ã—Ö
    try:
        # await session.execute(text("PRAGMA foreign_keys = OFF;"))  # OFF check FK in sqlite
        await session.execute(
            text("SET CONSTRAINTS ALL DEFERRED;")
        )  # OFF check FK in sqlite
        await session.execute(
            text(f'TRUNCATE TABLE "{model_db.__tablename__}" RESTART IDENTITY CASCADE;')
        )
        # await session.execute(delete(model_db))
        await session.commit()
        print(f"–¢–∞–±–ª–∏—Ü–∞ {model_db.__tablename__} –æ—á–∏—â–µ–Ω–∞")
    except Exception as e:
        await session.rollback()
        raise HTTPException(
            status_code=500, detail=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Ç–∞–±–ª–∏—Ü—ã: {str(e)}"
        )

    def parse_datetime(item):
        if "created" in item:
            item["created"] = datetime.strptime(item["created"], "%d.%m.%Y %H:%M:%S")
        if "updated" in item:
            item["updated"] = datetime.strptime(item["updated"], "%d.%m.%Y %H:%M:%S")
        return item

    # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è Product
    if model_name.value == "product":
        objects = []
        for item in data.get(model_name.value, []):
            # –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π –æ–±—ä–µ–∫—Ç Product –±–µ–∑ —Å–≤—è–∑–µ–π
            product_data = {k: v for k, v in parse_datetime(item).items()
                            if k not in ["tags", "images"]}
            product = model_db(**product_data)

            # –î–æ–±–∞–≤–ª—è–µ–º —Å–≤—è–∑–∏ –æ—Ç–¥–µ–ª—å–Ω–æ
            if "tags" in item:
                # –ü–æ–ª—É—á–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ç–µ–≥–∏ –∏–∑ –ë–î
                tag_ids = [tag["id"] for tag in item["tags"]]
                tags = await session.execute(
                    select(Tag).where(Tag.id.in_(tag_ids))
                )
                product.tags = tags.scalars().all()

            if "images" in item:
                # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
                images = [ProductImage(**img) for img in item["images"]]
                product.images = images

            objects.append(product)
    else:
        objects = [
            model_db(**parse_datetime(item)) for item in data.get(model_name.value, [])
        ]

    try:
        session.add_all(objects)
        await session.commit()
    except IntegrityError as e:
        await session.rollback()
        return JSONResponse(
            status_code=400, content={"detail": "Integrity error", "error": str(e)}
        )
    # –û–±–Ω–æ–≤–∏—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–ª—è –ø–æ–ª—è id
    try:
        column_check = await session.execute(
            text(
                f"""
                    SELECT column_name 
                    FROM information_schema.columns 
                    WHERE table_name = '{model_db.__tablename__}' AND column_name = 'id';
                    """
            )
        )
        has_id_column = column_check.scalar() is not None

        if has_id_column:
            await session.execute(
                text(
                    f"""
                        SELECT setval(
                        pg_get_serial_sequence('{model_db.__tablename__}', 'id'), 
                        (SELECT COALESCE(MAX(id), 0) FROM {model_db.__tablename__}) + 1,
                        false
                    );
                    """
                )
            )
            await session.commit()

    except Exception as e:
        await session.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: {str(e)}",
        )

    return {"message": f"–î–∞–Ω–Ω—ã–µ –∏–∑ {file_path} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –≤ –±–∞–∑—É"}
